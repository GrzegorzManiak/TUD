:root {
    --font-color: #22223B;
    --font-color-light: #4659DC;
    --page-indicator: #cdcbca;
    --page-indicator-active: #22223B;
}

#splashContent {
    display: flex;
    height: 100vh;
    flex-direction: column;
    align-content: center;
    align-items: center;
    width: 100vw;
}

#splashContentInner {
    display: flex;
    max-width: var(--max-width);
    width: 100%;
    height: 100%;
    align-items: center;
    justify-content: space-between;
}

.splashTextContent {
    padding: 1rem;
    max-width: 50%;
}

.splashTextContent p {
    margin: 0;
    padding: 0;
}

.splashTextContent p b {
    font-weight: 900;
    color: var(--font-color);
    font-size: 2.5rem;
}

.splashTextContent p b a {
    color: var(--font-color-light);
}


/*
    Landing squares
*/

.splashImgContent {
    /*
        Declaring the display as grid allows me
        to allow the squares to overlap

        i use transform: translateX(x, y)
        Because it alows me to move the squares
        vertically and horizontally within the grid.

        As margin-top/bottom dosent work within a grid.
    */
    display: grid;
    transform: scale(1.3);
    width: 17rem;
}

.splashImgContent div {
    grid-row: 1;
    grid-column: 1;
}

.square1 {
    border-radius: 1rem;
    width: 12rem;
    height: 12rem;
    background-color: #22223B;
    transform: rotate(2.5deg);
    z-index: 15;
}

.square2 {
    border-radius: 1.2rem;
    width: 6rem;
    height: 6rem;
    background-color: #323264;
    transform: rotate(6.5deg);
    transform: translate(-3rem, -3rem);
    z-index: 14;
}

.square3 {
    border-radius: 2em;
    width: 3rem;
    height: 3rem;
    background-color: #B4B6DE;
    transform: rotate(6.5deg);
    transform: translate(1rem, -1.5rem);
    z-index: 14;
}

.square4 {
    border-radius: 1em;
    width: 4rem;
    height: 4rem;
    background-color: #464697;
    transform: rotate(-32deg);
    transform: translate(-2rem, 2rem);
    z-index: 14;
}

.square5 {
    border-radius: 1em;
    width: 6rem;
    height: 6rem;
    background-color: #4B4B7A;
    transform: rotate(-10deg);
    transform: translate(9rem, 9rem);
    z-index: 14;
}

.square6 {
    border-radius: 1.5em;
    width: 3.5rem;
    height: 3.5rem;
    background-color: #7073BF;
    transform: rotate(5deg);
    transform: translate(7rem, 10rem);
    z-index: 14;
}

#pageIndicator {
    position: fixed;
    bottom: 1rem;
}

.pageIndicatorElement {
    background-color: var(--page-indicator);
    width: 0.8rem;
    height: 0.8rem;
    margin: 0.2rem;
    border-radius: 1rem;
    transition: all 0.25s ease;
}

.pageIndicatorElement:hover {
    transform: scale(1.25);
}

.pageIndicatorElement:active {
    transform: scale(0.95);
}

.pageIndicatorElementActive {
    background-color: var(--page-indicator-active);
}


/*
    About us section
*/

#aboutUs {
    padding: 1rem;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}

#aboutUs h1 {
    font-size: 5rem;
    font-weight: 900;
    color: var(--font-color);
    margin: 0;
    padding: 0;
    width: 75%;
    text-align: center;
}

.aboutusSelector {
    width: 50%
}

.aboutusSelector img {
    width: 100%;
    height: auto;
    border-radius: 0.5rem;
}


/*
    So,

    This is the carousel, the workings of it are described in the main.js file.
    I created this carousel with the use of keyframes, transform, and js.

    There are keyframes for,

    [1] When the images are first loaded in.
    [2] When the images are moved to the left.
    [3] When the images are moved to the right.
    [4] When the images are moved to the center.
    [5] When the images are loaded in from the stack.

    The stack is an array it contains the images that are hidden as only 3 images are visible at a time.
        [ img, img, img, img ] <-- The stack.
    left img, center img, right img

    as an image is pushed off one side, it's loaded into the appropriate side of the array.
    eg you click the left image in the carousel, causing the image that's in the center, to be pushed to the right,
    and the image that was in the right beforehand gets pushed into the right side of the array.

                       V-- That's the img we just added to the stack.
    [ img, img, img, img ] <-- The stack.

    as we moved that left image to the center, we now have an empty spot on the left side of the carousel,
    now we can load an image to fill in that empty spot by pulling it from the left side of the stack and then
    removing it from the stack.

        V-- That's the image we just loaded in from the stack.
    [ img, img, img, img ] <-- The stack.

    I won't go over the 150 lines, but ill go over every unique rule.

    scale(1), this transform changes the scales of the element, pretty self-explanatory.

    translateX() and translateY(), these two move the element in the x and y-axis accordingly.
    eg they used to move the elements to the left and right, up and down.
    you can set the values back to 0 and the element will return to its original position.

            y
            *
            *
            *
    x********
    
    rotateY(deg) this rotates the element in the y axis, I tried explaining this but I don't know how to make it sound good.
    literally, pick up any item, hold it up
    and turn your wrist, thas your Y,

    the z-index is like BOMDAS, it's an order of precedence, the higher the number, the higher the priority.
    eg you could have this.

    <img style='z-index: 50' src='./imgs/img1.png'>
    <img style='z-index: 100' src='./imgs/img2.png'>

    if IMG1 overlapped (EG if both had their position's set to absolute) onto IMG2 you'd expect IMG1 to still be visible,
    but since we have a higher z-index set for IMG2, The image that will still be visible is IMG2.
*/

#carousel {
    display: grid;
    transform: scale(0.9);
}

#carousel img {
    grid-row: 1;
    grid-column: 1;
    transition: all 2s ease;
}

.carouselSelected {
    transform: scale(1);
    z-index: 100;
    animation: start 2s forwards ease;
}

.scaleInFromLeft {
    z-index: 110;
    transform: scale(1);
    animation: scaleInFromLeft 2s forwards;
}

.scaleInFromRight {
    z-index: 110;
    transform: scale(1);
    animation: scaleInFromRight 2s forwards;
}

.scaleOutToLeft {
    z-index: 90;
    transform: scale(1.15);
    animation: scaleOutToLeft 2s forwards;
}

.scaleOutToRight {
    z-index: 90;
    transform: scale(1.15);
    animation: scaleOutToRight 2s forwards;
}

.moveCenterFromLeft {
    z-index: 70;
    animation: moveCenterFromLeft 2s forwards;
}

.moveCenterFromRight {
    z-index: 70;
    animation: moveCenterFromRight 2s forwards;
}

.moveLeftFromCenter {
    z-index: 70;
    animation: moveLeftFromCenter 2s forwards;
}

.moveRightFromCenter {
    z-index: 70;
    animation: moveRightFromCenter 2s forwards;
}

@keyframes scaleInFromRight {
    0% {
        transform: scale(1) translateX(7rem) rotateY(160deg)
    }
    100% {
        z-index: 100;
        transform: scale(1.15) translateX(0) rotateY(0deg)
    }
}

@keyframes scaleInFromLeft {
    0% {
        transform: scale(1) translateX(-7rem) rotateY(-160deg)
    }
    100% {
        z-index: 100;
        transform: scale(1.15) translateX(0) rotateY(0deg)
    }
}

@keyframes scaleOutToRight {
    0% {
        transform: scale(1.15) translateX(0) rotateY(0deg);
    }
    100% {
        z-index: 90;
        transform: scale(1) translateX(7rem) rotateY(160deg);
    }
}

@keyframes scaleOutToLeft {
    0% {
        transform: scale(1.15) translateX(0) rotateY(0deg);
    }
    100% {
        z-index: 90;
        transform: scale(1) translateX(-7rem) rotateY(-160deg);
    }
}

@keyframes moveCenterFromRight {
    0% {
        opacity: 1.0;
        transform: scale(1) translateX(7rem);
    }
    100% {
        opacity: 0.0;
        transform: scale(1) translateX(0rem) rotateY(160deg);
    }
}

@keyframes moveCenterFromLeft {
    0% {
        opacity: 1.0;
        transform: scale(1) translateX(-7rem);
    }
    100% {
        opacity: 0.0;
        transform: scale(1) translateX(0rem) rotateY(-160deg);
    }
}

@keyframes moveRightFromCenter {
    0% {
        opacity: 0.0;
        transform: scale(0.5) translateX(0rem) rotateY(100deg);
    }
    100% {
        opacity: 1.0;
        transform: scale(1) translateX(7rem) rotateY(160deg);
    }
}

@keyframes moveLeftFromCenter {
    0% {
        opacity: 0.0;
        transform: scale(0.5) translateX(0rem) rotateY(100deg);
    }
    100% {
        opacity: 1.0;
        transform: scale(1) translateX(-7rem) rotateY(-160deg);
    }
}

@keyframes start {
    0% {
        transform: scale(0.9);
    }
    100% {
        transform: scale(1.15);
    }
}